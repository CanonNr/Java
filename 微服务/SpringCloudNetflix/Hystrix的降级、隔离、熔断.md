 # Hystrix的降级、隔离、熔断

## 服务降级

在高并发的情况下，**防止用户一直等待**，使用服务降级方式进行处理(返回友好的提示给客户端，fallback回调方法)。当服务不可用的时候(正在等待的时候、网络延迟、响应时间过长),客户端会处于一直等待的状态。显然一直等待是不合理的，所以我们应该给客户端返回一个友好的提示，使用fallback(回调方法)进行服务降级处理。

服务降级目的：如果遇到**连接超时**、**网络延迟**、**服务器响应时间过长**等情况，为了提高用户体验(自定义消息返回给客户端)，防止服务雪崩效应。

> 服务端和客户端对于降级的做法还是有一定差异的。

- 客户端降级：如果客户端发现服务端的服务不可用，那么不再请求服务端，直接返回一个固定的数据给调用方，对服务端的服务进行降级处理

- 服务端降级：如果服务端发现系统超负荷运行，为了系统的自身的稳定性，对特定的服务进行降级，比如直接返回错误或者固定数据

## 服务隔离

所谓隔离就是建立一个沙盒系统，不能因为一些服务的异常导致系统其它的服务不能正常的工作，对于java容器来说，可以利用线程池技术，把各种服务建立独立的线程池，当异常服务的线程池满了之后，不能再使用系统资源，防止系统资源被耗尽，导致整个系统不可用

- 服务隔离有2种实现方式，线程池方式、信号量。

  1.线程池方式：相当于每个接口(服务)都有自己独立的线程池，不同的线程池之间互不影响，能够实现服务接口隔离。缺点：CPU、内存开销较大。

  2.信号量方式：底层使用原子计数器(atomic)，针对于每个服务都设置自己的独立的限制阈值。比如设置每个服务接口

  最多同时访问的次数，如果超出缓存队列请求后，自己实现拒绝策略。

## 熔断

在高并发的情况下，如果达到一定的极限或阈值，就拒绝访问，保护当前服务。当服务器达到最大的承受能力的之后，直接拒绝访问服务，然后调用降级方法，返回友好提示。

目的：为了防止服务宕机(保护服务)，会进行熔断处理。

产生的原因：服务请求过多，高并发情况下。可以设置阈值进行限制。超出的请求存放在缓存队列中，如果缓存队列中线程满的话，直接拒绝访问服务，访问不了服务(熔断)。

- 熔断的三种状态
  1. **Closed**：熔断器关闭状态，调用失败次数积累，到了阈值（或一定比例）则启动熔断机制；
  2. **Open**：熔断器打开状态，此时对下游的调用都内部直接返回错误，不走网络，但设计了一个时钟选项，默认的时钟达到了一定时间（这个时间一般设置成平均故障处理时间，也就是MTTR），到了这个时间，进入半熔断状态；
  3. **Half-Open**：半熔断状态，允许定量的服务请求，如果调用都成功（或一定比例）则认为恢复了，关闭熔断器，否则认为还没好，又回到熔断器打开状态；
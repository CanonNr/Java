 # Hystrix的降级、隔离、熔断

## 服务降级

在高并发的情况下，**防止用户一直等待**，使用服务降级方式进行处理(返回友好的提示给客户端，fallback回调方法)。当服务不可用的时候(正在等待的时候、网络延迟、响应时间过长),客户端会处于一直等待的状态。显然一直等待是不合理的，所以我们应该给客户端返回一个友好的提示，使用fallback(回调方法)进行服务降级处理。

服务降级目的：如果遇到**连接超时**、**网络延迟**、**服务器响应时间过长**等情况，为了提高用户体验(自定义消息返回给客户端)，防止服务雪崩效应。

> 服务端和客户端对于降级的做法还是有一定差异的。

- 客户端降级：如果客户端发现服务端的服务不可用，那么不再请求服务端，直接返回一个固定的数据给调用方，对服务端的服务进行降级处理

- 服务端降级：如果服务端发现系统超负荷运行，为了系统的自身的稳定性，对特定的服务进行降级，比如直接返回错误或者固定数据

## 服务隔离

所谓隔离就是建立一个沙盒系统，不能因为一些服务的异常导致系统其它的服务不能正常的工作，对于java容器来说，可以利用线程池技术，把各种服务建立独立的线程池，当异常服务的线程池满了之后，不能再使用系统资源，防止系统资源被耗尽，导致整个系统不可用

- 服务隔离有2种实现方式，线程池方式、信号量。

  1.线程池方式：相当于每个接口(服务)都有自己独立的线程池，不同的线程池之间互不影响，能够实现服务接口隔离。缺点：CPU、内存开销较大。

  2.信号量方式：底层使用原子计数器(atomic)，针对于每个服务都设置自己的独立的限制阈值。比如设置每个服务接口

  最多同时访问的次数，如果超出缓存队列请求后，自己实现拒绝策略。

## 熔断

在高并发的情况下，如果达到一定的极限或阈值，就拒绝访问，保护当前服务。当服务器达到最大的承受能力的之后，直接拒绝访问服务，然后调用降级方法，返回友好提示。

目的：为了防止服务宕机(保护服务)，会进行熔断处理。

产生的原因：服务请求过多，高并发情况下。可以设置阈值进行限制。超出的请求存放在缓存队列中，如果缓存队列中线程满的话，直接拒绝访问服务，访问不了服务(熔断)。

- 熔断的三种状态
  1. **Closed**：熔断器关闭状态，调用失败次数积累，到了阈值（或一定比例）则启动熔断机制；
  2. **Open**：熔断器打开状态，此时对下游的调用都内部直接返回错误，不走网络，但设计了一个时钟选项，默认的时钟达到了一定时间（这个时间一般设置成平均故障处理时间，也就是MTTR），到了这个时间，进入半熔断状态；
  3. **Half-Open**：半熔断状态，允许定量的服务请求，如果调用都成功（或一定比例）则认为恢复了，关闭熔断器，否则认为还没好，又回到熔断器打开状态；





## 工作流程

> Hystrix 就把上面说的熔断，隔离，限流，降级封装在这么一个组件里面，下图是 Hystrix 内部设计和调用流程

![img](../../image/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzc0MzcxLzIwMTkwNi83NzQzNzEtMjAxOTA2MjgxNTEyMTAxNDEtMTg3MDIwMDAzMi5qcGc-1599445291231.jfif)

- 构建一个 `HystrixCommand` 对象，用于封装请求，并在构造方法配置请求被执行需要的参数。
- 执行命令，Hystrix 提供了几种执行命令的方法，比较常用到的是 **Synchrous** 和 **Asynchrous**。
- 判断电路是否被打开，如果被打开，直接进入 `Fallback` 方法。
- 判断**线程池/队列/信号量**是否已经满，如果满了，直接进入 `Fallback` 方法。
- 执行 Run 方法，一般是` HystrixCommand.run()`，进入实际的业务中，若执行超时或执行失败抛出未提前预计的异常时，直接进入` Fallback` 方法。
- 无论中间走到哪一步都会进行上报` Metrics`，统计出熔断器的监控指标。
- `Fallback `方法也分实现和备用的环节。
- 最后是返回请求响应。
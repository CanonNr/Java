# 简述

CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。

CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。

在Java并发编程中最初接触的应该就是`synchronized` 、`volatile`，这种独占锁属于**悲观锁**，它是在假设一定会发生冲突的，那么加锁恰好有用，除此之外，还有**乐观锁**，乐观锁的含义就是假设没有发生冲突，那么我正好可以进行某项操作，如果要是发生冲突呢，那我就重试直到成功，乐观锁最常见的就是`CAS`。

用生活中的例子：你爸把电视电视调在了中央1台，等他晚上下班的时候只需要看一下开机后是不是还在中央一台，如果不在了你一定是偷偷看电视了。为什么在中央1台就不是一定没看呢？这也是 CAS 一个缺陷也就是ABA的问题即你看完电视可能正巧又停在了中央一台上。

# 如何实现

CAS通过调用JNI的代码实现的。JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言。而compareAndSwapInt就是借助C来调用CPU底层指令实现的。

# 优缺点

## 优点：

很简单就一句话：他比锁快

## 缺点：

1. 循环时间长开销很大。
2. 只能保证一个共享变量的原子操作。
3. ABA问题。

- **循环时间长开销很大：**我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。至于为什么是循环请求，因为拿不到锁是很正常的现象如果遇到锁就终止线程了永远也打不到预期效果了。

- **只能保证一个共享变量的原子操作：**当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。

- **ABA**：单纯只是看值判断有没有修改可能出现，修改一次后又被修改回去，以为没有发生改变实则是有变化的。、

  解决方法：

  - 不再单纯的看值，添加一个版本号的属性，每次修改都加一个版本号

  - jdk1.5 之后引入了 `AtomicStampedreference`来解决ABA问题。它通过包装`[E,Integer]`的元组来对对象标记版本戳stamp，从而避免ABA问题。

    ```java
    public boolean compareAndSet(
        V      expectedReference,//预期引用
        V      newReference,//更新后的引用
        int    expectedStamp, //预期标志
        int    newStamp //更新后的标志
    ) 
    ```

    

# 疑问

- 会不会在 CAS 查询期望值的瞬间被改变了，从而导致数据的错乱

  不会，因为CAS是CPU指令级别的支持中间不会被打断

